```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Merry Christmas</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Ma+Shan+Zheng&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      background-color: #020205;
      font-family: 'Cinzel', serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }

    #ui-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.3) 100%);
    }

    #main-title {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      text-align: center;
      font-family: 'Cinzel', serif;
      font-weight: 800;
      font-size: clamp(36px, 7vw, 80px);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      pointer-events: none;
      z-index: 20;
      opacity: 0;
      min-height: 1.2em;

      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-image: linear-gradient(180deg, #fffdf0 0%, #eacda3 30%, #d6ae7b 60%, #8b6c42 100%);
      filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.6));

      animation: titleFadeIn 2s ease-out forwards 1s;
      transition: filter 1.5s ease, background-image 1.5s ease;
    }

    @keyframes titleFadeIn {
      from { opacity: 0; transform: translate(-50%, -20px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }

    #loader {
      position: absolute;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 1.2s;
      pointer-events: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 2px solid rgba(212, 175, 55, 0.1);
      border-top: 2px solid #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    /* ‰π¶‰ø°Â±ïÁ§∫Â±Ç */
    #letter-overlay {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 150;
      background: rgba(0,0,0,0.4);
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      opacity: 0;
      transition: opacity 1.0s ease;
    }
    .letter-paper {
      height: 80%;
      aspect-ratio: 3/4;
      background: rgba(255, 252, 240, 0.15);
      backdrop-filter: blur(3px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 6vh;
      box-sizing: border-box;
      position: relative;
      display: flex;
      flex-direction: column;
      transform: translateY(20px);
      transition: transform 1.0s ease-out;
    }
    .letter-content {
      font-family: 'Ma Shan Zheng', cursive;
      font-size: clamp(16px, 2.5vh, 24px);
      line-height: 1.8;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 5px rgba(255,215,0, 0.3);
      white-space: pre-wrap;
      overflow-y: auto;
      flex: 1;
      scroll-behavior: smooth;
    }
    .letter-content::-webkit-scrollbar { width: 6px; }
    .letter-content::-webkit-scrollbar-thumb { background: rgba(212, 175, 55, 0.3); border-radius: 3px; }
    .cursor::after { content: '|'; animation: blink 1s step-end infinite; }
    @keyframes blink { 50% { opacity: 0; } }

    .letter-close-btn {
      position: absolute; top: 15px; right: 15px;
      width: 30px; height: 30px;
      border: 1px solid rgba(255,255,255,0.4);
      border-radius: 50%;
      color: rgba(255,255,255,0.7);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      user-select: none;
    }
    .letter-close-btn:hover {
      background: rgba(255,255,255,0.2);
      color: #fff;
      border-color: #fff;
    }

    /* ÊëÑÂÉèÂ§¥Âè™ÂêéÂè∞ËØÜÂà´ÔºöÂÆåÂÖ®‰∏çÊòæÁ§∫ */
    #webcam {
      position: fixed;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="loader"><div class="spinner"></div></div>
  <div id="canvas-container"></div>

  <div id="ui-layer">
    <div id="main-title"></div>
  </div>

  <div id="letter-overlay">
    <div class="letter-paper">
      <div class="letter-close-btn" id="btn-close-letter-mode">√ó</div>
      <div class="letter-content" id="letter-content-display"></div>
    </div>
  </div>

  <!-- ÊëÑÂÉèÂ§¥ÔºöÂè™Áî®‰∫éÂêéÂè∞ÊâãÂäøËØÜÂà´ -->
  <video id="webcam" autoplay playsinline muted></video>

  <!-- Âõ∫ÂÆöÈü≥‰πê -->
  <audio id="bg-music" loop preload="auto" crossorigin="anonymous"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // =========================
    // Âõ∫ÂÆöËµÑÊ∫êÈÖçÁΩÆ
    // =========================
    const ASSETS = {
      title: "Merry Christmas",
      musicUrl: "assets/music/bgm.mp3",
      photoManifestUrl: "assets/photo/manifest.json",
      letterUrl: "assets/letter/my.txt",
    };

    const CONFIG = {
      colors: {
        bg: 0x020205, gold: 0xffd700, red: 0x880000, green: 0x004400,
        iceBlue: 0xaaddff, iceCyan: 0x00ffff, iceMagenta: 0xff00cc,
        white: 0xffffff,
        barbieHot: 0xff1694, barbieSoft: 0xffb7c5
      },
      particles: {
        count: 1800, dustCount: 1500, treeHeight: 28, treeRadius: 9,
        snowCount: 2500, snowSpeed: 10
      },
      camera: { z: 55 },
      gesture: {
        okPinch: 0.055,          // OK(ÊãáÊåá+È£üÊåá)ÈòàÂÄº
        debounceMs: 1200,        // ÊâãÂäøÈò≤Êäñ
        minPalm: 0.10            // ÊâãÊéåÂ∞∫Â∫¶‰∏ãÈôêÔºàÈÅøÂÖçËøúË∑ùÁ¶ªËØØÂà§Ôºâ
      }
    };

    const STATE = {
      mode: 'TREE',
      currentThemeIndex: 0,

      // Âõ∫ÂÆö‰π¶‰ø°
      letterContent: "",
      letterTyper: null,
      letterStartTimer: null,
      lastLetterTrig: 0,
      lastThemeTrig: 0,

      rotation: { x: 0, y: 0 },
      time: 0,

      starMesh: null,
      starHaloMesh: null,
    };

    let scene, camera, renderer, composer, clock = new THREE.Clock();
    let mainGroup, starGroup, bgGroup, photoMeshGroup, particleSystem = [];
    let galaxySystem = null, snowSystem = null, heartSystem = null;

    let caneTexture, snowTexture, heartTexture, matLib = {};

    // MediaPipe
    let handLandmarker = null;
    let videoEl = null;
    let lastVideoTime = -1;

    const _tempVec = new THREE.Vector3();

    function setFixedTitle() {
      document.title = ASSETS.title;
      const t = document.getElementById('main-title');
      if (t) t.innerText = ASSETS.title;

      // Èò≤Ê≠¢Ë¢´Â§ñÈÉ®Êîπ DOM
      if (t) {
        const mo = new MutationObserver(() => {
          if (t.innerText !== ASSETS.title) t.innerText = ASSETS.title;
        });
        mo.observe(t, { childList: true, characterData: true, subtree: true });
      }
    }

    // ËøõÂÖ•È°µÈù¢Â∞ΩÈáèÊí≠ÊîæÔºöÈùôÈü≥È¢ÑÁÉ≠ + Á¨¨‰∏ÄÊ¨°‰∫§‰∫íÁ°Æ‰øùÊúâÂ£∞Âæ™ÁéØ
    function wireFixedMusic() {
      const audioEl = document.getElementById('bg-music');
      audioEl.src = ASSETS.musicUrl;
      audioEl.loop = true;
      audioEl.preload = "auto";
      audioEl.crossOrigin = "anonymous";

      // ÈùôÈü≥È¢ÑÁÉ≠ÔºàÈÉ®ÂàÜÊµèËßàÂô®ÂÖÅËÆ∏Ôºâ
      audioEl.muted = true;
      audioEl.play().catch(() => {});

      // Á¨¨‰∏ÄÊ¨°Áî®Êà∑‰∫§‰∫í -> ÊâìÂºÄÂ£∞Èü≥ÁªßÁª≠Âæ™ÁéØ
      const startWithSound = () => {
        audioEl.muted = false;
        audioEl.play().catch(() => {});
      };
      window.addEventListener('pointerdown', startWithSound, { once: true });
      window.addEventListener('keydown', startWithSound, { once: true });
    }

    async function loadFixedLetter() {
      try {
        const resp = await fetch(ASSETS.letterUrl, { cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const txt = await resp.text();
        STATE.letterContent = (txt ?? "").trim();
      } catch (e) {
        console.warn("Letter load failed:", e);
        STATE.letterContent = "";
      }
    }

    function resolvePhotoUrl(entry) {
      if (typeof entry !== "string") return null;
      const s = entry.trim();
      if (!s) return null;
      if (/^(https?:)?\/\//i.test(s) || s.startsWith("/") || s.startsWith("assets/")) return s;
      return "assets/photo/" + s.replace(/^\.\/+/, "");
    }

    async function loadPhotosFromManifest() {
      let list = [];
      try {
        const resp = await fetch(ASSETS.photoManifestUrl, { cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();

        if (Array.isArray(data)) list = data;
        else if (Array.isArray(data.photos)) list = data.photos;
        else if (Array.isArray(data.images)) list = data.images;
        else if (Array.isArray(data.files)) list = data.files;
        else list = [];
      } catch (e) {
        console.warn("Photo manifest load failed:", e);
        list = [];
      }

      const urls = list.map(resolvePhotoUrl).filter(Boolean);
      if (!urls.length) return;

      const loader = new THREE.TextureLoader();
      urls.forEach((url) => {
        loader.load(
          url,
          (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t); },
          undefined,
          (err) => console.warn("Texture load failed:", url, err)
        );
      });
    }

    async function init() {
      setFixedTitle();

      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createMaterials();

      createGalaxyBackground();
      createSnowBackground();
      createHeartBackground();

      createParticles();
      setupPostProcessing();
      setupEvents();

      wireFixedMusic();
      await loadFixedLetter();
      await loadPhotosFromManifest();

      switchTheme(0);

      // ÂêéÂè∞ÊâãÂäøËØÜÂà´Ôºà‰∏çÊòæÁ§∫ÊëÑÂÉèÂ§¥Ôºâ
      initMediaPipe().catch(console.warn);

      const loader = document.getElementById('loader');
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 1200);

      animate();
    }

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 0, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", depth: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      bgGroup = new THREE.Group(); scene.add(bgGroup);
      mainGroup = new THREE.Group(); mainGroup.rotation.x = 0.1; scene.add(mainGroup);
      starGroup = new THREE.Group(); mainGroup.add(starGroup);
      photoMeshGroup = new THREE.Group(); mainGroup.add(photoMeshGroup);
    }

    function setupEnvironment() {
      const pmrem = new THREE.PMREMGenerator(renderer);
      pmrem.compileEquirectangularShader();
      scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
    }

    function setupLights() {
      scene.add(new THREE.AmbientLight(0xffffff, 0.2));
      const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 3, 40);
      bottomLight.position.set(0, -10, 10);
      mainGroup.add(bottomLight);

      const spotGold = new THREE.SpotLight(0xfff0dd, 800);
      spotGold.position.set(40, 60, 40); spotGold.angle = 0.4; spotGold.decay = 2;
      scene.add(spotGold);

      const spotBlue = new THREE.SpotLight(0x4455ff, 400);
      spotBlue.position.set(-40, 10, -30); spotBlue.lookAt(0,0,0);
      scene.add(spotBlue);
    }

    function setupPostProcessing() {
      const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloom.threshold = 0.75; bloom.strength = 0.5; bloom.radius = 0.5;
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      composer.addPass(bloom);
    }

    function createFrostTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#666'; ctx.fillRect(0,0,256,256);
      for(let i=0; i<80; i++) {
        ctx.strokeStyle = `rgba(255,255,255,${0.2 + Math.random()*0.5})`;
        ctx.lineWidth = Math.random() * 2 + 0.5;
        ctx.beginPath();
        const x = Math.random()*256, y = Math.random()*256;
        ctx.moveTo(x, y);
        ctx.lineTo(x + (Math.random()-0.5)*60, y + (Math.random()-0.5)*60);
        ctx.stroke();
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }

    function createTextures() {
      const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
      ctx.fillStyle = '#aa0000'; ctx.beginPath();
      for(let i=-128; i<256; i+=32) {
        ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0);
      }
      ctx.fill();
      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.colorSpace = THREE.SRGBColorSpace;
      caneTexture.wrapS = THREE.RepeatWrapping; caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);

      const snowCvs = document.createElement('canvas'); snowCvs.width = 32; snowCvs.height = 32;
      const sCtx = snowCvs.getContext('2d');
      const grad = sCtx.createRadialGradient(16,16,0, 16,16,16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      sCtx.fillStyle = grad; sCtx.fillRect(0,0,32,32);
      snowTexture = new THREE.CanvasTexture(snowCvs);

      const hCvs = document.createElement('canvas'); hCvs.width = 64; hCvs.height = 64;
      const hCtx = hCvs.getContext('2d');
      hCtx.fillStyle = '#ffffff';
      hCtx.beginPath();
      hCtx.moveTo(32, 20);
      hCtx.bezierCurveTo(32, 17, 30, 10, 20, 10);
      hCtx.bezierCurveTo(10, 10, 10, 25, 10, 25);
      hCtx.bezierCurveTo(10, 35, 20, 42, 32, 55);
      hCtx.bezierCurveTo(44, 42, 54, 35, 54, 25);
      hCtx.bezierCurveTo(54, 25, 54, 10, 44, 10);
      hCtx.bezierCurveTo(36, 10, 32, 17, 32, 20);
      hCtx.fill();
      heartTexture = new THREE.CanvasTexture(hCvs);
    }

    function createMaterials() {
      matLib.gold = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.15, envMapIntensity: 2.5,
        emissive: 0x664400, emissiveIntensity: 0.2
      });
      matLib.green = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.green, metalness: 0.4, roughness: 0.3,
        emissive: 0x001100, emissiveIntensity: 0.1
      });
      matLib.red = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.red, metalness: 0.6, roughness: 0.2,
        clearcoat: 1.0, emissive: 0x330000, emissiveIntensity: 0.4
      });
      matLib.candy = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.3, metalness: 0.1, emissive: 0x222222 });

      matLib.starGold = new THREE.MeshStandardMaterial({
        color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 2.0, metalness: 1.0, roughness: 0
      });
      matLib.frameGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 });

      const frostTex = createFrostTexture();
      matLib.ice = new THREE.MeshPhysicalMaterial({
        color: 0xffffff, metalness: 0.1, roughness: 0.05,
        transmission: 0.95, thickness: 1.5, ior: 1.8,
        clearcoat: 1.0, envMapIntensity: 2.0,
        emissive: CONFIG.colors.iceBlue, emissiveIntensity: 0.3,
        map: frostTex
      });

      matLib.frozenCyan = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.iceCyan, metalness: 0.8, roughness: 0.2,
        emissive: CONFIG.colors.iceCyan, emissiveIntensity: 2.0, clearcoat: 1.0
      });
      matLib.frozenMagenta = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.iceMagenta, metalness: 0.5, roughness: 0.2,
        emissive: CONFIG.colors.iceMagenta, emissiveIntensity: 1.5, clearcoat: 1.0
      });
      matLib.starIce = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.iceCyan, emissive: 0xffffff, emissiveIntensity: 3.0,
        metalness: 0.2, roughness: 0, transmission: 0.6, thickness: 3.0
      });
      matLib.snow = new THREE.MeshStandardMaterial({
        color: 0xffffff, metalness: 0.1, roughness: 0.8,
        emissive: 0xaaaaaa, emissiveIntensity: 0.8
      });

      matLib.barbieMain = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.barbieHot, metalness: 0.2, roughness: 0.1,
        clearcoat: 1.0, emissive: 0x440022, emissiveIntensity: 0.3
      });
      matLib.barbieSoft = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.barbieSoft, metalness: 0.1, roughness: 0.4,
        emissive: 0x442233, emissiveIntensity: 0.2
      });
      matLib.starBarbie = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.barbieHot, emissive: 0xff0088, emissiveIntensity: 4.0,
        metalness: 0.5, roughness: 0.1
      });
      matLib.frameBarbie = matLib.barbieMain;

      matLib.snowBorder = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.BackSide });
      matLib.frameIce = matLib.ice;
      matLib.dust = new THREE.MeshBasicMaterial({ color: 0xffffee, blending: THREE.AdditiveBlending });

      matLib.snowFlake = new THREE.PointsMaterial({
        color: 0xffffff, size: 0.8, map: snowTexture, transparent: true, opacity: 0.9,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
      matLib.heartFlake = new THREE.PointsMaterial({
        color: CONFIG.colors.barbieHot, size: 1.5, map: heartTexture, transparent: true, opacity: 0.6,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
    }

    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh; this.type = type; this.isDust = isDust;
        this.posTree = new THREE.Vector3();
        this.baseScale = mesh.scale.x;
        this.offset = Math.random() * 100;
        this.speed = 0.5 + Math.random();
        this.hasEmissive = !!(mesh.material && mesh.material.emissive);
        this.calculatePositions();
      }
      calculatePositions() {
        const h = CONFIG.particles.treeHeight;
        let t = Math.random();
        if (Math.random() > 0.7 && !this.isDust && this.type !== 'PHOTO') {
          const y = (t * h) - h/2, angle = t * Math.PI * 12, rBase = CONFIG.particles.treeRadius * (1.0 - t);
          this.posTree.set(Math.cos(angle) * rBase, y, Math.sin(angle) * rBase);
        } else {
          t = Math.pow(t, 0.8);
          const y = (t * h) - h/2, angle = Math.random() * Math.PI * 2;
          const r = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t)) * Math.sqrt(Math.random());
          this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
        }
      }
      update(dt, time, mode) {
        let target = this.posTree;
        let s = this.baseScale, lerpSpeed = 3.0;

        _tempVec.copy(target);
        if(mode === 'TREE') {
          const floatScale = (STATE.currentThemeIndex === 1) ? 0.3 : 0.15;
          _tempVec.y += Math.sin(time * this.speed + this.offset) * floatScale;
          _tempVec.x += Math.cos(time * 0.5 * this.speed + this.offset) * 0.1;
        }
        this.mesh.position.lerp(_tempVec, lerpSpeed * dt);

        if (this.hasEmissive && mode === 'TREE' && !this.isDust && this.type !== 'PHOTO') {
          const blink = Math.sin(time * 2 + this.offset);
          const maxEmit = (STATE.currentThemeIndex === 1) ? 3.0 : 2.5;
          this.mesh.material.emissiveIntensity = blink > 0.5 ? (1.0 + (blink - 0.5) * maxEmit) : 0.4;
        }

        if (this.isDust) s = this.baseScale * (0.5 + 0.5 * Math.sin(time * 3 + this.offset));
        this.mesh.scale.lerp(_tempVec.set(s,s,s), 5*dt);
      }
    }

    function createGalaxyBackground() {
      const geometry = new THREE.BufferGeometry(), count = 3000;
      const pos = new Float32Array(count * 3), colors = new Float32Array(count * 3);
      const c1 = new THREE.Color(0x88aaff), c2 = new THREE.Color(0xffffee), c3 = new THREE.Color(0xffd700);
      for(let i=0; i<count; i++) {
        const r = 60 + Math.random()*250, theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
        pos[i*3] = r*Math.sin(phi)*Math.cos(theta);
        pos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
        pos[i*3+2] = r*Math.cos(phi);
        let c = Math.random(), finalC = c<0.6?c2:(c<0.9?c1:c3);
        colors[i*3]=finalC.r; colors[i*3+1]=finalC.g; colors[i*3+2]=finalC.b;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      galaxySystem = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({ size: 1.0, transparent: true, opacity: 0.8, vertexColors: true, sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false })
      );
      bgGroup.add(galaxySystem);
    }

    function createSnowBackground() {
      const geometry = new THREE.BufferGeometry();
      const count = CONFIG.particles.snowCount;
      const pos = new Float32Array(count * 3);
      const velocities = new Float32Array(count);

      for(let i=0; i<count; i++) {
        pos[i*3] = (Math.random() - 0.5) * 100;
        pos[i*3+1] = (Math.random() - 0.5) * 100;
        pos[i*3+2] = (Math.random() - 0.5) * 60;
        velocities[i] = 1.0 + Math.random();
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

      snowSystem = new THREE.Points(geometry, matLib.snowFlake);
      snowSystem.visible = false;
      bgGroup.add(snowSystem);
    }

    function createHeartBackground() {
      const geometry = new THREE.BufferGeometry();
      const count = 1500;
      const pos = new Float32Array(count * 3);
      const velocities = new Float32Array(count);

      for(let i=0; i<count; i++) {
        pos[i*3] = (Math.random() - 0.5) * 120;
        pos[i*3+1] = (Math.random() - 0.5) * 120;
        pos[i*3+2] = (Math.random() - 0.5) * 80;
        velocities[i] = 0.5 + Math.random() * 0.8;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

      heartSystem = new THREE.Points(geometry, matLib.heartFlake.clone());
      heartSystem.visible = false;
      bgGroup.add(heartSystem);
    }

    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0,-0.5,0), new THREE.Vector3(0,0.3,0),
        new THREE.Vector3(0.1,0.5,0), new THREE.Vector3(0.3,0.4,0)
      ]);
      const candyGeo = new THREE.TubeGeometry(curve, 8, 0.08, 6, false);
      const dustGeo = new THREE.OctahedronGeometry(0.1, 0);

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random(); let mesh, type;
        if (rand < 0.35) { mesh = new THREE.Mesh(boxGeo, matLib.green); type = 'BOX'; }
        else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, matLib.gold); type = 'GOLD_BOX'; }
        else if (rand < 0.90) { mesh = new THREE.Mesh(sphereGeo, matLib.gold); type = 'GOLD_SPHERE'; }
        else if (rand < 0.96) { mesh = new THREE.Mesh(sphereGeo, matLib.red); type = 'RED'; }
        else { mesh = new THREE.Mesh(candyGeo, matLib.candy); type = 'CANE'; }

        const s = 0.4 + Math.random() * 0.4;
        mesh.scale.set(s,s,s);
        mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      for(let i=0; i<CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(dustGeo, matLib.dust);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }

      createStarTopper();
    }

    function createStarTopper() {
      const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), matLib.starGold);
      star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
      const halo = new THREE.Mesh(
        new THREE.PlaneGeometry(8, 8),
        new THREE.MeshBasicMaterial({
          map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png'),
          blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.5, color: 0xffaa00
        })
      );
      star.add(halo);
      starGroup.add(star);
      STATE.starMesh = star;
      STATE.starHaloMesh = halo;
    }

    function switchTheme(themeIndex) {
      STATE.currentThemeIndex = themeIndex;

      const titleEl = document.getElementById('main-title');
      if (titleEl) {
        if (themeIndex === 0) {
          titleEl.style.color = '#d4af37';
          titleEl.style.textShadow = '0 0 15px rgba(212, 175, 55, 0.4), 0 0 30px rgba(212, 175, 55, 0.2)';
        } else if (themeIndex === 1) {
          titleEl.style.color = '#e0ffff';
          titleEl.style.textShadow = '0 0 15px rgba(0, 255, 255, 0.6), 0 0 30px rgba(0, 255, 255, 0.4), 0 0 45px rgba(170, 221, 255, 0.3)';
        } else {
          titleEl.style.color = '#ff69b4';
          titleEl.style.textShadow = '0 0 15px rgba(255, 22, 148, 0.6), 0 0 30px rgba(255, 183, 197, 0.4)';
        }
      }

      renderer.toneMappingExposure = (themeIndex === 1) ? 1.2 : (themeIndex === 2 ? 0.9 : 1.0);

      if (galaxySystem) galaxySystem.visible = (themeIndex === 0);
      if (snowSystem) snowSystem.visible = (themeIndex === 1);
      if (heartSystem) heartSystem.visible = (themeIndex === 2);

      const fogColor = (themeIndex === 2) ? 0x1a0510 : ((themeIndex === 1) ? 0x000510 : CONFIG.colors.bg);
      scene.fog.color.setHex(fogColor);
      scene.background.setHex(fogColor);

      // ‰∏ªÈ¢òÊùêË¥®ÂàáÊç¢ÔºàÂåÖÂê´ÁÖßÁâáÊ°ÜÔºâ
      particleSystem.forEach(p => {
        if (p.isDust) {
          if (themeIndex === 2) p.mesh.material.color.setHex(CONFIG.colors.barbieSoft);
          else if (themeIndex === 1) p.mesh.material.color.setHex(CONFIG.colors.iceCyan);
          else p.mesh.material.color.setHex(0xffffee);
          return;
        }

        if (p.type === 'PHOTO') {
          const group = p.mesh;
          let frameMat = (themeIndex === 0) ? matLib.frameGold : (themeIndex === 1 ? matLib.frameIce : matLib.frameBarbie);
          if (group.children[0]) group.children[0].material = frameMat;
          if (group.children[2]) group.children[2].visible = (themeIndex !== 0);
          return;
        }

        let newMat;
        if (themeIndex === 0) {
          if(p.type.includes('GOLD')) newMat = matLib.gold;
          else if(p.type === 'BOX') newMat = matLib.green;
          else if(p.type === 'RED') newMat = matLib.red;
          else if(p.type === 'CANE') newMat = matLib.candy;
        } else if (themeIndex === 1) {
          if(p.type === 'GOLD_SPHERE') newMat = matLib.frozenCyan;
          else if(p.type === 'GOLD_BOX' || p.type === 'BOX') newMat = matLib.ice;
          else if(p.type === 'RED') newMat = matLib.frozenMagenta;
          else if(p.type === 'CANE') newMat = matLib.snow;
        } else {
          if(p.type.includes('GOLD')) newMat = matLib.barbieMain;
          else if(p.type === 'BOX') newMat = matLib.barbieSoft;
          else if(p.type === 'RED') newMat = matLib.starBarbie;
          else if(p.type === 'CANE') newMat = matLib.barbieMain;
        }
        if (newMat) p.mesh.material = newMat;
      });

      if (STATE.starMesh && STATE.starHaloMesh) {
        if(themeIndex === 0) {
          STATE.starMesh.material = matLib.starGold;
          STATE.starHaloMesh.material.color.setHex(0xffaa00);
        } else if(themeIndex === 1) {
          STATE.starMesh.material = matLib.starIce;
          STATE.starHaloMesh.material.color.setHex(CONFIG.colors.iceCyan);
        } else {
          STATE.starMesh.material = matLib.starBarbie;
          STATE.starHaloMesh.material.color.setHex(CONFIG.colors.barbieHot);
        }
      }
    }

    function addPhotoToScene(texture) {
      if (!texture.image) return;
      const aspect = texture.image.width / texture.image.height;
      let photoW = (aspect >= 1) ? 1.2 : 1.2 * aspect;
      let photoH = (aspect >= 1) ? 1.2 / aspect : 1.2;

      const group = new THREE.Group();
      const frameGeo = new THREE.BoxGeometry(photoW + 0.15, photoH + 0.15, 0.1);

      const currentFrameMat = (STATE.currentThemeIndex === 0) ? matLib.frameGold : (STATE.currentThemeIndex === 1 ? matLib.frameIce : matLib.frameBarbie);
      const frame = new THREE.Mesh(frameGeo, currentFrameMat);
      group.add(frame);

      const photo = new THREE.Mesh(new THREE.PlaneGeometry(photoW, photoH), new THREE.MeshBasicMaterial({ map: texture }));
      photo.position.z = 0.06;
      group.add(photo);

      const borderGeo = new THREE.BoxGeometry(photoW + 0.25, photoH + 0.25, 0.08);
      const border = new THREE.Mesh(borderGeo, matLib.snowBorder);
      border.position.z = -0.02;
      border.visible = (STATE.currentThemeIndex !== 0);
      group.add(border);

      photoMeshGroup.add(group);
      particleSystem.push(new Particle(group, 'PHOTO', false));
    }

    function enterLetterMode() {
      if (STATE.mode === 'LETTER') return;
      if (!STATE.letterContent || STATE.letterContent.trim() === "") return;

      STATE.mode = 'LETTER';
      const overlay = document.getElementById('letter-overlay');
      const paper = document.querySelector('.letter-paper');
      const display = document.getElementById('letter-content-display');

      overlay.style.display = 'flex';
      requestAnimationFrame(() => {
        overlay.style.opacity = 1;
        paper.style.transform = 'translateY(0)';
      });

      display.textContent = '';
      display.classList.remove('cursor');

      let i = 0;
      const typeWriter = () => {
        if (STATE.mode !== 'LETTER') return;
        if (i < STATE.letterContent.length) {
          display.textContent += STATE.letterContent.charAt(i++);
          display.scrollTop = display.scrollHeight;
          STATE.letterTyper = setTimeout(typeWriter, 80);
        } else {
          display.classList.remove('cursor');
        }
      };

      STATE.letterStartTimer = setTimeout(() => {
        if (STATE.mode === 'LETTER') {
          display.classList.add('cursor');
          typeWriter();
        }
      }, 800);
    }

    function exitLetterMode() {
      STATE.mode = 'TREE';
      clearTimeout(STATE.letterTyper);
      clearTimeout(STATE.letterStartTimer);

      const overlay = document.getElementById('letter-overlay');
      const paper = document.querySelector('.letter-paper');
      overlay.style.opacity = 0;
      paper.style.transform = 'translateY(20px)';
      setTimeout(() => { overlay.style.display = 'none'; }, 400);
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      STATE.time = clock.elapsedTime;

      if (STATE.mode === 'LETTER') {
        STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, Math.PI/4, dt * 1.5);
        STATE.rotation.y -= 0.1 * dt;
      } else {
        const baseSpeed = (STATE.currentThemeIndex === 1) ? 0.6 : 0.4;
        STATE.rotation.y -= baseSpeed * dt;
        STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0.15, dt * 2.0);
      }

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      // ËÉåÊôØÁ≤íÂ≠ê
      if (galaxySystem && galaxySystem.visible) {
        bgGroup.rotation.y -= 0.05 * dt;
      } else if ((snowSystem && snowSystem.visible) || (heartSystem && heartSystem.visible)) {
        const sys = snowSystem.visible ? snowSystem : heartSystem;
        const positions = sys.geometry.attributes.position.array;
        const velocities = sys.geometry.attributes.velocity.array;
        const count = snowSystem.visible ? CONFIG.particles.snowCount : 1500;

        for(let i=0; i<count; i++) {
          positions[i*3+1] -= CONFIG.particles.snowSpeed * velocities[i] * dt;
          if (positions[i*3+1] < -50) positions[i*3+1] = 50;
        }
        sys.geometry.attributes.position.needsUpdate = true;
        bgGroup.rotation.y -= 0.02 * dt;
      }

      if (STATE.starMesh) {
        STATE.starMesh.rotation.y -= dt;
        STATE.starMesh.rotation.z = Math.sin(STATE.time) * 0.2;
        STATE.starMesh.scale.setScalar(1.0 + Math.sin(STATE.time * 2) * 0.1);
      }

      particleSystem.forEach(p => p.update(dt, STATE.time, STATE.mode));
      composer.render();
    }

    function setupEvents() {
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // Âè™‰øùÁïô‰π¶‰ø°ÂÖ≥Èó≠ÊåâÈíÆÔºà‰Ω†Ë¶ÅÊ±Ç‰øùÁïôÔºâ
      document.getElementById('btn-close-letter-mode').addEventListener('click', (e) => {
        e.stopPropagation();
        exitLetterMode();
      });
    }

    // =========================
    // Á∫ØÊâãÂäø‰∫§‰∫íÔºàÊó†‰ªª‰ΩïUIÊåâÈíÆÔºâ
    // ÊâãÂäøÂÆö‰πâÔºö
    // 1) üëç Á´ñÊãáÊåáÔºöÂàáÊç¢‰∏ªÈ¢òÔºàÂæ™ÁéØ 3 ÁßçÔºâ
    // 2) üëå OKÔºöÊâìÂºÄ‰π¶‰ø°ÔºàÊúâÂÜÖÂÆπÊâç‰ºöÊâìÂºÄÔºâ
    // =========================
    async function initMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      videoEl = document.getElementById('webcam');

      if (!navigator.mediaDevices?.getUserMedia) return;

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } },
        audio: false
      });

      videoEl.srcObject = stream;

      // Êüê‰∫õÊµèËßàÂô®ÈúÄË¶Å loadeddata ÂêéÊâçËÉΩÊãøÂà∞ currentTime
      videoEl.addEventListener("loadeddata", () => {
        videoEl.play().catch(()=>{});
        requestAnimationFrame(predictWebcam);
      }, { once: true });
    }

    function dist(lm, i, j) {
      return Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
    }

    function isThumbsUp(lm) {
      // ÂÖ≥ÈîÆË∑ùÁ¶ªÔºöÊéåÂøÉÂ∞∫Â∫¶
      const palm = dist(lm, 0, 9);
      if (palm < CONFIG.gesture.minPalm) return false;

      const thumbExtended = dist(lm, 4, 9) > palm * 0.90;
      const indexCurled  = dist(lm, 8, 9) < palm * 0.70;
      const middleCurled = dist(lm, 12, 9) < palm * 0.70;
      const ringCurled   = dist(lm, 16, 9) < palm * 0.70;
      const pinkyCurled  = dist(lm, 20, 9) < palm * 0.70;

      return thumbExtended && indexCurled && middleCurled && ringCurled && pinkyCurled;
    }

    function isOKGesture(lm) {
      // ÊãáÊåá(4)‰∏éÈ£üÊåá(8)ÊçèÂêà
      const pinch = dist(lm, 4, 8);
      if (pinch > CONFIG.gesture.okPinch) return false;

      // ÂêåÊó∂Ë¶ÅÊ±Ç‰∏≠Êåá‰º∏Âá∫ÔºåÈôç‰ΩéËØØËß¶
      const palm = dist(lm, 0, 9);
      if (palm < CONFIG.gesture.minPalm) return false;

      const middleExtended = dist(lm, 12, 0) > palm * 1.30;
      return middleExtended;
    }

    function processGestures(lm) {
      if (!lm) return;

      // ‰π¶‰ø°Ê®°ÂºèÊó∂Ôºå‰∏çÂìçÂ∫î‰∏ªÈ¢òÂàáÊç¢/ÂÜçÊ¨°ÂºÄ‰ø°
      if (STATE.mode === 'LETTER') return;

      const now = Date.now();

      // üëå OK -> ÊâìÂºÄ‰π¶‰ø°
      if (isOKGesture(lm)) {
        if (STATE.letterContent && (now - STATE.lastLetterTrig > CONFIG.gesture.debounceMs)) {
          STATE.lastLetterTrig = now;
          enterLetterMode();
          return;
        }
      }

      // üëç -> ÂàáÊç¢‰∏ªÈ¢ò
      if (isThumbsUp(lm)) {
        if (now - STATE.lastThemeTrig > CONFIG.gesture.debounceMs) {
          STATE.lastThemeTrig = now;
          switchTheme((STATE.currentThemeIndex + 1) % 3);
          return;
        }
      }
    }

    async function predictWebcam() {
      if (!handLandmarker || !videoEl) {
        requestAnimationFrame(predictWebcam);
        return;
      }

      if (lastVideoTime !== videoEl.currentTime) {
        lastVideoTime = videoEl.currentTime;
        const result = handLandmarker.detectForVideo(videoEl, performance.now());
        if (result.landmarks?.[0]) processGestures(result.landmarks[0]);
      }

      requestAnimationFrame(predictWebcam);
    }

    init();
  </script>
</body>
</html>
```
